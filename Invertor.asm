global _start
N equ 100
section .bss
var_read: resb N
var_write: resb N
section .text
_start:
	mov rax, 0
	mov rdi, 0
	mov rsi, var_read
	mov rdx, N
	syscall ; считаем информацию с клавиатуры и поместим её в переменную var_read

	mov rcx, N
	label_1:
		mov rbx, rcx
		dec rbx ; rbx = rcx - 1
		mov al, [var_read + rbx] ; символ, обрабатываемой в данной итерации цикла, находится в однобайтном регистре al
		
		cmp al, 'A' ; если обрабатываемый символ априори оказался не латинской буквой...
		jb not_a_letter

		cmp al, 'z' ; если обрабатываемый символ априори оказался не латинской буквой...
		ja not_a_letter

		cmp al, 'Z' ; если обрабатываемый символ -- заглавная латинская буква...
		jna from_upper_to_low

		cmp al, 'a' ; если обрабатываемый символ -- прописная латинская буква...
		jnb from_low_to_upper

		jmp not_a_letter ; если предыдущие проверки не прошли, то имеем не что иное, как один из сиволов с кодом в диапазоне от 91 до 96: в таком случае, это тоже не латинская буква

	not_a_letter:
		mov [var_write + rbx], al ; если обрабатываемый символ -- не латинская буква, то без изменений копируем её в соответствующий байт переменной var_write
		cmp rcx, 2
		jl end ; предпроверка счётчика: если rcx == 1, то следующая команда loop занулит регистр rcx и переход на метку label_1 (в начало цикла) не состоится
                loop label_1 ; если исключить предпроверку, то программа пойдёт дальше, а обрабатываемый символ подвергнется изменениям в других метках, что недопустимо

	from_upper_to_low:
		add al, 'a' - 'A'
		mov [var_write + rbx], al ; если обрабатываемый символ -- заглавная латинская буква, то изменим её регистр и скопируем её в соответствующий байт переменной var_write
		cmp rcx, 2
                jl end ; предпроверка счётчика: если rcx == 1, то следующая команда loop занулит регистр rcx и переход на метку label_1 (в начало цикла) не состоится
                loop label_1 ; если исключить предпроверку, то программа пойдёт дальше, а обрабатываемый символ подвергнется изменениям в других метках, что недопустимо

	from_low_to_upper:
		sub al, 'a' - 'A'
                mov [var_write + rbx], al ; если обрабатываемый символ -- строчная латинская буква, то изменим её регистр и скопируем её в соответствующий байт переменной var_write
                loop label_1 ; здесь предпроверку можно не делать: последующих меток нет, так что при занулении rcx команда loop не сработает, зато сразу перейдёт к выводу var_write
	end:	

	mov rax, 1
	mov rdi, 1
	mov rsi, var_write
	mov rdx, N
	syscall ; выведем на экран значение ячейки памяти var_write

	mov rax, 60
	xor rdi, rdi
	syscall
	ret

